//SetGameType returns which game mode should be used for which map prefix
//You can do whatever you want with this. You can even use Options
// (options => the ?blah=blah things added after the map name when launching a server or in the map list)
//to add even more variety. See the ParseOption function in Src\Engine\Classes\GameInfo.uc
var config array<GameTypePrefix> SDKPrefixes;

var bool bLockedTeams;
var array<string> LockedAgathaPlayerSteamIDs, LockedMasonPlayerSteamIDs;

var globalconfig bool bRestartMapAfterEndGame;

// Ranked Mode
var globalconfig bool bRankedMode;
var globalconfig int iRankedTeamSize;
var globalconfig int iRankedGameSize;
var float fRankedModeMatchMakeInterval;
var string sRankedModeChatColour;
var bool bRankedModeMatchMade;
var bool bRankedModeReadyToStartMatch;
var string sRankedModeMatchResponseData;
var RankedGame RankedGame;

// Custom player votes
var delegate<CustomVoteOnComplete> dCustomVoteOnComplete;
var int iVoteRankedTeamSize;


delegate CustomVoteOnComplete(bool bSuccess);


static event class<GameInfo> SetGameType(string MapName, string Options, string Portal)
{
    local string ThisMapPrefix;
    local int i, pos;
    local class<GameInfo> NewGameType;

    LogAlwaysInternal("SetGameType is being called on" @ default.Class);

    MapName = StripPlayOnPrefix(MapName);

    // replace self with appropriate gametype if no game specified
    pos = InStr(MapName, "-");
    ThisMapPrefix = left(MapName, pos);

    for (i = 0; i < default.SDKPrefixes.length; i++)
    {
        if (default.SDKPrefixes[i].Prefix ~= ThisMapPrefix)
        {
            NewGameType = class<GameInfo>(DynamicLoadObject(default.SDKPrefixes[i].GameType, class'Class'));
            if (NewGameType != None)
            {
                return NewGameType;
            }
        }
    }

    return super.SetGameType(MapName, Options, Portal);
}

event InitGame(string Options, out string ErrorMessage)
{
    local RankedGame PreviousRankedGame;

    super.InitGame(Options, ErrorMessage);

    // Preserve actors which should persist through seamless travel
    if (WorldInfo.IsInSeamlessTravel())
    {
        // Look for the RankedGame instance
        foreach DynamicActors(Class'RankedGame', PreviousRankedGame)
        {
            // Conditions to keep the previous RankedGame
            if (bRankedMode                                                                 &&  // Ranked mode is still enabled
                PreviousRankedGame.MatchmakingResponse != ""                                &&  // A game was successfully made
                PreviousRankedGame.CompletedMatches.Length < PreviousRankedGame.GameSize    &&  // There's still matches to play
                PreviousRankedGame.Map == string(WorldInfo.GetPackageName())                &&  // The next map is as expected
                !PreviousRankedGame.Cancelled)                                                  // The game wasn't cancelled
            {
                RankedGame = PreviousRankedGame;
                break;
            }
        }
    }

    if (bRankedMode)
    {
        // Spawn a new RankedGame instance if one wasn't found
        if (RankedGame == none)
            RankedGame = Spawn(class'RankedGame');

        // Autobalance
        bAutoBalance = false;
        bDeathBasedAutoBalance = false;
        AOCGRI(GameReplicationInfo).bBalanceTeams = false;

        bUseMaxPingLimit = false;
        bDisableTeamDamagePenalty = true;
        fServerTeamDamagePercent = 1.0f;
        fTeamDamagePercent = 1.0f;
        bAdminCanPause = true;
        bAnyUserCanGetSteamID = true;
    }

    // Ensure Tournament Mode and Ranked Mode are not both enabled at the same time
    if ((bTournamentMode || default.bTournamentMode) && (bRankedMode || default.bRankedMode))
    {
        ConfigureTournamentMode(false);
        ConfigureRankedMode(false);
        WorldInfo.ServerTravel("?restart", false);
    }
}

event GetSeamlessTravelActorList(bool bToEntry, out array<Actor> ActorList)
{
    super.GetSeamlessTravelActorList(bToEntry, ActorList);

    if (RankedGame != none)
        ActorList[ActorList.Length] = RankedGame;
}

event PostLogin(PlayerController NewPlayer)
{
    super.PostLogin(NewPlayer);

    // Save original name if it hasn't already been saved
    `{GAMEMODE}PRI(NewPlayer.PlayerReplicationInfo).SaveOriginalName();

    // Check if they are a whitelisted admin and log them in if they are
    ImbaModAccessControl(AccessControl).LoginAdminIfWhitelisted(NewPlayer);
}


function GenericPlayerInitialization(Controller C)
{
    super.GenericPlayerInitialization(C);

    if (bRankedMode)
    {
        // Connect player to remote service and rename them to display their elo
        class'RankedAPI'.static.OnUserConnect(OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(C.PlayerReplicationInfo.UniqueId),
                                              PlayerController(C).GetPlayerNetworkAddress(),
                                              OnUserConnectOnComplete);
    }
    else
    {
        // Try to restore the player's original name
        `{GAMEMODE}PRI(C.PlayerReplicationInfo).RestoreOriginalName();
    }
}

function AddInactivePRI(PlayerReplicationInfo PRI, PlayerController PC)
{
    local int i;
    local PlayerReplicationInfo NewInactivePRI, InactivePRI;

    // Only save if it's NOT an old PRI from before seamless travel
    if (!PRI.bFromPreviousLevel)
    {
        NewInactivePRI = PRI.Duplicate();
        WorldInfo.GRI.RemovePRI(NewInactivePRI);

        // Make PRI inactive
        NewInactivePRI.RemoteRole = ROLE_None;

        // Delete after 1 hour (or after seamless travel)
        NewInactivePRI.LifeSpan = 3600;

        // Remove any null references or duplicates if found
        for (i = 0; i < InactivePRIArray.Length; i++)
        {
            InactivePRI = InactivePRIArray[i];

            if (InactivePRI == None || InactivePRI.UniqueId == NewInactivePRI.UniqueId)
            {
                InactivePRIArray.Remove(i, 1);
                i--;
            }
        }

        // Add PRI to saved inactive PRIs
        InactivePRIArray[InactivePRIArray.Length] = NewInactivePRI;

        // Cap at 100 saved inactive PRIs
        if (InactivePRIArray.Length > 100)
            InactivePRIArray.Remove(0, InactivePRIArray.Length - 100);
    }

    PRI.Destroy();
    RecalculateSkillRating();
}

function bool FindInactivePRI(PlayerController PC)
{
    local int i;
    local PlayerReplicationInfo PRI, InactivePRI;

    PRI = PC.PlayerReplicationInfo;

    for (i = 0; i < InactivePRIArray.Length; i++)
    {
        InactivePRI = InactivePRIArray[i];

        if (InactivePRI == None)
        {
            InactivePRIArray.Remove(i, 1);
            i--;
        }
        else if (InactivePRI.UniqueId == PRI.UniqueId)
        {
            PC.PlayerReplicationInfo = InactivePRI;
            PC.PlayerReplicationInfo.SetOwner(PC);
            PC.PlayerReplicationInfo.RemoteRole = ROLE_SimulatedProxy;
            PC.PlayerReplicationInfo.Lifespan = 0;
            OverridePRI(PC, PRI);
            WorldInfo.GRI.AddPRI(PC.PlayerReplicationInfo);
            InactivePRIArray.Remove(i, 1);
            PRI.bIsInactive = true;
            PRI.Destroy();

            return true;
        }
    }

    return false;
}

function Logout(Controller Exiting)
{
    super.Logout(Exiting);

    // Done regardless of bRankedMode to address some edge-cases where players were not disconnected from remote service
    class'RankedAPI'.static.OnUserDisconnect(OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(Exiting.PlayerReplicationInfo.UniqueId));
}

function bool ShouldCountDown()
{
    local int AgathaSize, MasonSize;
    local int AgathaMod, MasonMod;
    local int AgathiansReady, MasonsReady;
    local int CorrectedAgathaSize, CorrectedMasonSize;
    local bool bCanSpawn;
    local bool bEachTeamHasAtleastOnePlayer;

    local Controller C;
    local AOCPlayerController PC;

    AgathaMod = 0;
    MasonMod = 0;
    foreach WorldInfo.AllControllers(class'Controller', C)
    {
        PC = AOCPlayerController(C);
        bCanSpawn = (PC != none && PC.CurrentFamilyInfo != none && PC.bReady) || AOCAIController(C) != none;

        if (CMWTO2GRI(GameReplicationInfo) != none && AOCAIController(C) != none)
        {
            //bots cannot trigger countdown in TO2 (is breaking horde-type maps)
            continue;
        }

        if (!bCanSpawn)
        {
            continue;
        }

        if (AOCPRI(C.PlayerReplicationInfo).IsOnTeam(EAOCFaction(Teams[0].TeamIndex)))
        {
            AgathaSize += 1;

            if (PC.IsVoluntarySpectator())
            {
                AgathaMod += 1;
            }
            else if (PC.bTournamentReady)
            {
                AgathiansReady += 1;
            }
        }
        else if (AOCPRI(C.PlayerReplicationInfo).IsOnTeam(EAOCFaction(Teams[1].TeamIndex)))
        {
            MasonSize += 1;

            if (PC.IsVoluntarySpectator())
            {
                MasonMod += 1;
            }
            else if (PC.bTournamentReady)
            {
                MasonsReady += 1;
            }
        }
    }

    CorrectedAgathaSize = AgathaSize - AgathaMod;
    CorrectedMasonSize = MasonSize - MasonMod;

    bEachTeamHasAtleastOnePlayer = (CorrectedAgathaSize > 0 && CorrectedMasonSize > 0);

    if (bTournamentMode)
    {
        return
        (
            bEachTeamHasAtleastOnePlayer &&
            (
                // each team has more than the minimum tolerable amount of 'ready' players
                (
                    (AgathiansReady / float(CorrectedAgathaSize)) >= TournamentTeamReadyThreshold &&
                    (MasonsReady / float(CorrectedMasonSize)) >= TournamentTeamReadyThreshold
                )

                // or an admin forced the match to start
                || bAdminForcedTournamentReady
            )
        );
    }
    else if (bRankedMode)
    {
        return (bEachTeamHasAtleastOnePlayer && bRankedModeReadyToStartMatch);
    }
    else
    {
        return (bEachTeamHasAtleastOnePlayer || !bWaitForTeams);
    }
}

function StartRound()
{
    local AOCPlayerController PC;

     // Reset everyone's stats before starting the game for the first time
    if (bBeforeFirstRound)
    {
        foreach WorldInfo.AllControllers(class'AOCPlayerController', PC)
        {
            AOCPRI(PC.PlayerReplicationInfo).PreSeamlessTravelReset();
            AOCPRI(PC.PlayerReplicationInfo).bNetDirty = true;
        }
    }

    super.StartRound();
}

function EndGame(PlayerReplicationInfo Winner, string Reason)
{
    super.EndGame(Winner, Reason);

    if (bRankedMode && bRankedModeMatchMade && sRankedModeMatchResponseData != "")
        SetTimer(3.0f, false, 'RankedModeEndGame');
}

function string GetNextMap()
{
    if (bRestartMapAfterEndGame)
        return "?restart";
    else
        return super.GetNextMap();
}

function bool RequestJoinTeam(AOCPlayerController inController, EAOCFaction inTeam, optional bool bForce = false)
{
    local string ControllerSteamID, RequirementSteamID;
    local array<string> TargetTeamSteamIDs;


    // If not using locked teams via steamIDs, use vanilla autobalance if applicable
    if (!bLockedTeams)
        return super.RequestJoinTeam(inController, inTeam, bForce);


    ControllerSteamID = OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(inController.PlayerReplicationInfo.UniqueId);

    // Resolve which team's locked-in steamIDs to check
    if (inTeam == EFAC_AGATHA)
        TargetTeamSteamIDs = LockedAgathaPlayerSteamIDs;
    else if (inTeam == EFAC_MASON)
        TargetTeamSteamIDs = LockedMasonPlayerSteamIDs;
    else
    {
        // Reject
        if (!bForce)
            inController.Response_JoinTeam(inTeam, false);
        return false;
    }

    foreach TargetTeamSteamIDs(RequirementSteamID)
    {
        if (ControllerSteamID == RequirementSteamID)
        {
            // Accept
            if (!bForce)
                inController.Response_JoinTeam(inTeam, true);

            AOCPRI(inController.PlayerReplicationInfo).SetNextTeam(inTeam);
            return true;
        }
    }

    // Reject
    if (!bForce)
        inController.Response_JoinTeam(inTeam, false);
    return false;
}

function RequestJoinClass(AOCPlayerController inController, EAOCFaction inTeam, byte inClass, optional bool bForce = false, optional bool bSetClass = false)
{
    local string ControllerSteamID, RequirementSteamID;
    local array<string> TargetTeamSteamIDs;


    // If not using locked teams via steamIDs, use vanilla
    if (!bLockedTeams)
        super.RequestJoinClass(inController, inTeam, inClass, bForce, bSetClass);


    ControllerSteamID = OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(inController.PlayerReplicationInfo.UniqueId);

    // Resolve which team's locked-in steamIDs to check
    if (inTeam == EFAC_AGATHA)
        TargetTeamSteamIDs = LockedAgathaPlayerSteamIDs;
    else if (inTeam == EFAC_MASON)
        TargetTeamSteamIDs = LockedMasonPlayerSteamIDs;
    else
    {
        // Reject
        if (!bForce)
            inController.Response_JoinClass(inClass, false);
        return;
    }

    foreach TargetTeamSteamIDs(RequirementSteamID)
    {
        if (ControllerSteamID == RequirementSteamID)
        {
            // Accept
            if (!bForce)
            {
                inController.Response_JoinClass(inClass, true);
                AOCPRI(inController.PlayerReplicationInfo).SetNextClass(EAOCClass(inClass));
                return;
            }
        }
    }

    // Reject
    if (!bForce)
        inController.Response_JoinClass(inClass, false);
}

// Deprecated
function AdminTournamentMode(bool bEnable){}

function AdminChangeTeam(AOCPlayerController ChangeInstigator, String PlayerName)
{
    local AOCPlayerController Target;
    local int Offset, i;


    if (!AccessControl.IsAdmin(ChangeInstigator))
        return;

    Target = AOCPlayerController(AccessControl.GetControllerFromString(PlayerName));

    if (Target == none)
        return;

    if (AOCFamilyInfo_Agatha_King(Target.CurrentFamilyInfo) != none || AOCFamilyInfo_Mason_King(Target.CurrentFamilyInfo) != none)
        return;

    if (Target.CurrentFamilyInfo.FamilyFaction == EFAC_Agatha)
        Offset = 5;
    else
        Offset = -5;

    for (i = 0; i < ArrayCount(AOCGRI(GameReplicationInfo).FamilyInfos) && AOCGRI(GameReplicationInfo).FamilyInfos[i] != Target.CurrentFamilyInfo; ++i);
        i += Offset;

    Target.SetNewClass(AOCGRI(GameReplicationInfo).FamilyInfos[i]);
}

function AdminChangeTeamDamageAmount(AOCPlayerController ChangeInstigator, float Amount)
{
    if (!AccessControl.IsAdmin(ChangeInstigator) || bRankedMode)
        return;

    fTeamDamagePercent = Amount;
    UpdateGameSettings();
}

function UpdateVoteTally()
{
    local int VoteTimeLeft;

    switch(VoteCategory)
    {
    case EVOTECAT_KICK:
        VoteTimeLeft = Round(GetRemainingTimeForTimer('EndKickVote'));
        break;
    case EVOTECAT_ChangeMap:
        VoteTimeLeft = Round(GetRemainingTimeForTimer('EndChangeMapVote'));
        break;
    case EVOTECAT_RestartMap:
        VoteTimeLeft = Round(GetRemainingTimeForTimer('EndResetMapVote'));
        break;
    default:
        super.UpdateVoteTally();
        return;
    }

    if (VoteTimeLeft == -1)
        VoteTimeLeft = Round(GetRemainingTimeForTimer('EndCustomVote'));

    CountVotes();

    BroadcastSystemMessage(iLocVoteSecondsLeft,
        class'AOCSystemMessages'.static.CreateLocalizationdata("INVALIDDATA", String(VoteTimeLeft),""),
        class'AOCSystemMessages'.static.CreateLocalizationdata("INVALIDDATA", String(Round(100.0f * VotesYes/Float(VotesNo + VotesYes))),""),
        EFAC_ALL);
}

function bool DidVoteSucceed()
{
    local int NumVoters;

    CountVotes();
    NumVoters = VotesYes + VotesNo;

    if (Float(NumVoters) / (NumVoters + VoteAbstains) < fVoteMinAmountNonAbstainers)
    {
        BroadcastSystemMessage(iLocVoteFailedTooManyAbstain,
            class'AOCSystemMessages'.static.CreateLocalizationdata("INVALIDDATA", String(NumVoters),""),
            class'AOCSystemMessages'.static.CreateLocalizationdata("INVALIDDATA", String(NumVoters + VoteAbstains),""),
            EFAC_ALL);

        return false;
    }

    if (Float(VotesYes) / (NumVoters) <= fVoteSuccessThreshold)
    {
        BroadcastSystemMessage(iLocVoteFailedTooManyNo,
            class'AOCSystemMessages'.static.CreateLocalizationdata("INVALIDDATA", String(Round(100.0f * VotesYes/Float(VotesNo + VotesYes))),""),
            class'AOCSystemMessages'.static.CreateLocalizationdata("INVALIDDATA", String(100.0f * fVoteSuccessThreshold),""),
            EFAC_ALL);

        return false;
    }

    BroadcastSystemMessage(iLocVoteVotedYesVotedNo,
        class'AOCSystemMessages'.static.CreateLocalizationdata("INVALIDDATA", String(VotesYes),""),
        class'AOCSystemMessages'.static.CreateLocalizationdata("INVALIDDATA", String(VotesNo),""),
        EFAC_ALL);

    return true;
}

function CancelVote()
{
    ClearTimer('EndCustomVote');

    super.CancelVote();
}


Auto State AOCPreRound
{
    function BeginState(Name PreviousStateName)
    {
        super.BeginState(PreviousStateName);

        if (bRankedMode && !bRankedModeMatchMade && !bRankedModeReadyToStartMatch)
        {
            ClearTimer('RankedModeAttemptToMakeMatch');
            SetTimer(fRankedModeMatchMakeInterval, true, 'RankedModeAttemptToMakeMatch');
        }
    }
}


reliable server function BroadcastMessageToAll(string Message, optional string Colour)
{
    local AOCPlayerController PC;

    foreach WorldInfo.AllControllers(class'AOCPlayerController', PC)
    {
        PC.ReceiveChatMessage(Message, EFAC_ALL, false, (Colour != ""), Colour, false);
    }
}

function int GetActualPlayersCount()
{
    local AOCPlayerController PC;
    local int PlayerCount;

    foreach WorldInfo.AllControllers(class'AOCPlayerController', PC)
    {
        if (!PC.IsVoluntarySpectator() && PC.CurrentFamilyInfo != none && PC.bReady)
            PlayerCount += 1;
    }

    return PlayerCount;
}

function Array<String> GetActualPlayersSteamIDs()
{
    local AOCPlayerController PC;
    local Array<String> PlayerSteamIDs;

    foreach WorldInfo.AllControllers(class'AOCPlayerController', PC)
    {
        if (!PC.IsVoluntarySpectator() && PC.CurrentFamilyInfo != none && PC.bReady)
            PlayerSteamIDs.AddItem(OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(PC.PlayerReplicationInfo.UniqueId));
    }

    return PlayerSteamIDs;
}

function AOCPlayerController GetControllerViaSteamID64 (string SteamID64)
{
    local AOCPlayerController PC;

    foreach WorldInfo.AllControllers(class'AOCPlayerController', PC)
    {
        if (OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(PC.PlayerReplicationInfo.UniqueId) == SteamID64)
        {
            return PC;
        }
    }
}

function PlayerReplicationInfo GetPlayerReplicationInfoViaSteamID64 (string SteamID64)
{
    local PlayerReplicationInfo PRI;

    // Look in InactivePRIArray first to prevent getting the wrong PRI when the player is reconnecting
    foreach InactivePRIArray(PRI)
    {
        if (OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(PRI.UniqueId) == SteamID64)
        {
            return PRI;
        }
    }

    foreach WorldInfo.GRI.PRIArray(PRI)
    {
        if (OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(PRI.UniqueId) == SteamID64)
        {
            return PRI;
        }
    }

}

function ForceTeams(Array<String> AgathaPlayersSteamIDs, Array<String> MasonPlayersSteamIDs)
{
    local AOCPlayerController PC;
    local bool Handled;
    local EAOCFaction CurrentTeam;
    local AOCFamilyInfo CurrentClass, NewClass;
    local string ControllerSteamID64, RequirementSteamID64;
    local int i, NewClassIndex;


    if ((AgathaPlayersSteamIDs.length == 0 && MasonPlayersSteamIDs.length == 0) ||
        AOCFFAGRI(GameReplicationInfo) != none ||
        AOCDuelGRI(GameReplicationInfo) != none ||
        CDWDuelGRI(GameReplicationInfo) != none
    )
        return;


    // For all players on the server
    foreach WorldInfo.AllControllers(class'AOCPlayerController', PC)
    {
        Handled = false;

        // Get their current team, class and SteamID64
        CurrentTeam = AOCPRI(PC.PlayerReplicationInfo).GetCurrentTeam();
        CurrentClass = PC.CurrentFamilyInfo;
        ControllerSteamID64 = OnlineSubsystemSteamworks(OnlineSub).UniqueNetIdToInt64(PC.PlayerReplicationInfo.UniqueId);

        // Check if they should be on Agatha
        foreach AgathaPlayersSteamIDs(RequirementSteamID64)
        {
            // They should be on this team!
            if (ControllerSteamID64 == RequirementSteamID64)
            {
                Handled = true;

                // If they're already on the correct team just exit
                if (CurrentTeam == EFAC_AGATHA)
                    break;

                // If they're spectating then make them join the game
                if (CurrentTeam == EFAC_NONE)
                {
                    PC.GenericSwitchToObs(false);
                    PC.SetReady(true);
                }

                // If they have previously selected a class, get the equivalent from the opposing team
                if (CurrentClass != none)
                {

                    // Get the index of CurrentClass and resolve the index for the equivalent class in the opposing team
                    for (i = 0; i < ArrayCount(AOCGRI(GameReplicationInfo).FamilyInfos); ++i)
                    {
                        if (AOCGRI(GameReplicationInfo).FamilyInfos[i] == CurrentClass)
                        {
                            NewClassIndex = i - 5;  // Mason to Agatha
                            break;
                        }
                    }

                    NewClass = AOCGRI(GameReplicationInfo).FamilyInfos[NewClassIndex];

                }
                // Otherwise set them to Agatha Vanguard
                else
                    NewClass = AOCGRI(GameReplicationInfo).FamilyInfos[2];

                // Force them to the correct team
                PC.SetNewClass(NewClass);
                PC.SetReady(true);

                break;
            }
        }

        if (Handled)
            continue;

        // Check if they should be on Mason
        foreach MasonPlayersSteamIDs(RequirementSteamID64)
        {
            if (ControllerSteamID64 == RequirementSteamID64)
            {
                Handled = true;

                if (CurrentTeam == EFAC_MASON)
                    break;

                if (CurrentTeam == EFAC_NONE)
                {
                    PC.GenericSwitchToObs(false);
                    PC.SetReady(true);
                }

                if (CurrentClass != none)
                {

                    for (i = 0; i < ArrayCount(AOCGRI(GameReplicationInfo).FamilyInfos); ++i)
                    {
                        if (AOCGRI(GameReplicationInfo).FamilyInfos[i] == CurrentClass)
                        {
                            NewClassIndex = i + 5;  // Agatha to Mason
                            break;
                        }
                    }

                    NewClass = AOCGRI(GameReplicationInfo).FamilyInfos[NewClassIndex];

                }
                // Otherwise set them to Mason Vanguard
                else
                    NewClass = AOCGRI(GameReplicationInfo).FamilyInfos[7];

                PC.SetNewClass(NewClass);
                PC.SetReady(true);

                break;
            }
        }

        if (Handled)
            continue;

        // Those who shouldn't be on Agatha or Mason should be Spectators
        PC.JoinSpectatorTeam();
    }
}

function LockTeams(Array<String> AgathaPlayersSteamIDs, Array<String> MasonPlayersSteamIDs)
{
    local string SteamID;

    if ((AgathaPlayersSteamIDs.length == 0 && MasonPlayersSteamIDs.length == 0) ||
        AOCFFAGRI(GameReplicationInfo) != none ||
        AOCDuelGRI(GameReplicationInfo) != none ||
        CDWDuelGRI(GameReplicationInfo) != none
    )
        return;

    // Clear any previous requirements just in case
    LockedAgathaPlayerSteamIDs.Remove(0, LockedAgathaPlayerSteamIDs.length);
    LockedMasonPlayerSteamIDs.Remove(0, LockedMasonPlayerSteamIDs.length);

    bLockedTeams = true;

    // Add each new requirement (I tried doing it a more normal way but it didn't compile...)
    foreach AgathaPlayersSteamIDs(SteamID)
    {
        LockedAgathaPlayerSteamIDs.AddItem(SteamID);
    }
    SteamID = "";
    foreach MasonPlayersSteamIDs(SteamID)
    {
        LockedMasonPlayerSteamIDs.AddItem(SteamID);
    }

    ForceTeams(AgathaPlayersSteamIDs, MasonPlayersSteamIDs);
}

function UnlockTeams()
{
    bLockedTeams = false;
    LockedAgathaPlayerSteamIDs.Remove(0, LockedAgathaPlayerSteamIDs.length);
    LockedMasonPlayerSteamIDs.Remove(0, LockedMasonPlayerSteamIDs.length);
}

function RenamePlayerViaSteamID64(string SteamID64, string name)
{
    local AOCPlayerController PC;

    PC = GetControllerViaSteamID64(SteamID64);

    if (PC != none)
    {
        ChangeName(PC, name, true);
    }
}

exec function RestartMapAfterEndGame(bool bEnable)
{
    if (default.bRestartMapAfterEndGame == bEnable)
        return;

    BroadcastMessageToAll("Admin RestartMapAfterEndGame" @ bEnable);

    ConfigureRestartMapAfterEndGame(bEnable);
}

reliable server function ConfigureRestartMapAfterEndGame(bool bEnable)
{
    bRestartMapAfterEndGame = bEnable;
    SaveConfig();

    class'`{GAMEMODE}'.default.bRestartMapAfterEndGame = bEnable;
    class'`{GAMEMODE}'.static.StaticSaveConfig();
}

exec function TournamentMode(bool bEnable)
{
    if (default.bTournamentMode == bEnable)
        return;

    BroadcastMessageToAll("Admin TournamentMode" @ bEnable);

    if (bEnable)
        ConfigureRankedMode(false);

    ConfigureTournamentMode(bEnable);
    WorldInfo.ServerTravel("?restart", false);
}

reliable server function ConfigureTournamentMode(bool bEnable)
{
    bTournamentMode = bEnable;
    SaveConfig();

    class'AOCGame'.default.bTournamentMode = bEnable;
    class'AOCGame'.static.StaticSaveConfig();
}

// Ranked Mode
exec function RankedMode(bool bEnable)
{
    if (default.bRankedMode == bEnable)
        return;

    BroadcastMessageToAll("Admin RankedMode" @ bEnable);

    if (bEnable)
        ConfigureTournamentMode(false);

    ConfigureRankedMode(bEnable);
    WorldInfo.ServerTravel("?restart", false);
}

reliable server function ConfigureRankedMode(bool bEnable)
{
    bRankedMode = bEnable;
    SaveConfig();

    class'`{GAMEMODE}'.default.bRankedMode = bEnable;
    class'`{GAMEMODE}'.static.StaticSaveConfig();
}

exec function RankedTeamSize(int Size)
{
    if (Size <= 0 || Size > (MaxPlayers / 2) || Size == iRankedTeamSize)
        return;

    BroadcastMessageToAll("Admin RankedTeamSize" @ Size);

    ConfigureRankedTeamSize(Size);
}

reliable server function ConfigureRankedTeamSize(int Size)
{
    if (Size <= 0 || Size > (MaxPlayers / 2))
        return;

    iRankedTeamSize = Size;
    SaveConfig();

    class'`{GAMEMODE}'.default.iRankedTeamSize = Size;
    class'`{GAMEMODE}'.static.StaticSaveConfig();
}

function OnUserConnectOnComplete(HttpRequestInterface OriginalRequest, HttpResponseInterface Response, bool bDidSucceed)
{
    local JsonObject data;
    local string id;
    local int elo;
    local string name;

    // Request failed spectacularly
    if (Response == none || !bDidSucceed)
        return;

    // Request succeeded; Get the payload
    data = class'JsonObject'.static.DecodeJson(Response.GetContentAsString())
                                   .GetObject("response");

    // Response payload probably isn't what we're expecting
    if (data == none || data.GetBoolValue("success") == false)
        return;

    // Complete success :)
    data = data
        .GetObject("items")
        .ObjectArray[0];

    id = data.GetStringValue("_id");
    elo = data.GetIntValue("elo");
    name = data.GetStringValue("name");

    RenamePlayerViaSteamID64(id, "[" $ elo $ "]" @ name);
}

function RankedModeAttemptToMakeMatch()
{
    local int PlayerCount;

    PlayerCount = GetActualPlayersCount();

    // Cases to not bother POSTing remote service and to not bother sending notifications
    if (!bRankedMode ||
        PlayerCount == 0 ||
        bRankedModeMatchMade ||
        bRankedModeReadyToStartMatch
    )
        return;

    // Cases to not bother POSTing remote service and to notify players why
    // Unsupported gamemodes
    if (AOCFFAGRI(GameReplicationInfo) != none ||
        AOCDuelGRI(GameReplicationInfo) != none ||
        CDWDuelGRI(GameReplicationInfo) != none
    )
    {
        BroadcastMessageToAll("");
        BroadcastMessageToAll("Unsupported gamemode.", sRankedModeChatColour);
        BroadcastMessageToAll("Disable ranked mode for this gamemode!", sRankedModeChatColour);
        BroadcastMessageToAll("");
        return;
    }
    // Team Objective
    if (AOCTOGRI(GameReplicationInfo) != none)
    {
        BroadcastMessageToAll("");
        BroadcastMessageToAll("Team Objective has been disabled until the usual format of playing two halves is supported.", sRankedModeChatColour);
        BroadcastMessageToAll("Disable ranked mode for Team Objective for now!", sRankedModeChatColour);
        BroadcastMessageToAll("");
        return;
    }
    // Insufficient ready players
    if (PlayerCount < iRankedTeamSize * 2)
    {
        BroadcastMessageToAll("");
        BroadcastMessageToAll("Need at least" @ iRankedTeamSize * 2 @ "ready players to start a match.", sRankedModeChatColour);
        BroadcastMessageToAll("Note: Being in team-select or class-select is not being ready!", sRankedModeChatColour);
        BroadcastMessageToAll("Wait for more ready players to join or reduce the target team size.", sRankedModeChatColour);
        BroadcastMessageToAll("Trying again in" @ fRankedModeMatchMakeInterval @ "seconds...", sRankedModeChatColour);
        BroadcastMessageToAll("");
        return;
    }

    class'RankedAPI'.static.CalculateMatchMaking(GetActualPlayersSteamIDs(), iRankedTeamSize, CalculateMatchMakingOnComplete);
}

function RankedModeBroadcastMatchInfo()
{
    local JsonObject jMatchResponseData,
                     TeamOnePlayers,
                     TeamTwoPlayers,
                     Player;

    jMatchResponseData = class'JsonObject'.static.DecodeJson(sRankedModeMatchResponseData);

    TeamOnePlayers = jMatchResponseData
        .GetObject("response")
        .GetObject("items")
        .GetObject("Team1")
        .GetObject("players");

    TeamTwoPlayers = jMatchResponseData
        .GetObject("response")
        .GetObject("items")
        .GetObject("Team2")
        .GetObject("players");

    BroadcastMessageToAll("Agatha:", sRankedModeChatColour);
    foreach TeamOnePlayers.ObjectArray(Player)
    {
        BroadcastMessageToAll("    [" $ Player.GetIntValue("elo") $ "]" @ Player.GetStringValue("name"), sRankedModeChatColour);
    }

    BroadcastMessageToAll("Mason:", sRankedModeChatColour);
    foreach TeamTwoPlayers.ObjectArray(Player)
    {
        BroadcastMessageToAll("    [" $ Player.GetIntValue("elo") $ "]" @ Player.GetStringValue("name"), sRankedModeChatColour);
    }
}

function CalculateMatchMakingOnComplete(HttpRequestInterface OriginalRequest, HttpResponseInterface Response, bool bDidSucceed)
{
    local JsonObject data, team;
    local array<string> AgathaPlayerIDs, MasonPlayerIDs;

    // Request failed spectacularly
    if (Response == none || !bDidSucceed)
    {
        BroadcastMessageToAll("");
        BroadcastMessageToAll("Remote service failed to respond.", sRankedModeChatColour);
        BroadcastMessageToAll("Trying again in" @ fRankedModeMatchMakeInterval @ "seconds...", sRankedModeChatColour);
        BroadcastMessageToAll("");
        return;
    }

    // We have a response; Get the payload
    data = class'JsonObject'.static.DecodeJson(Response.GetContentAsString())
                                   .GetObject("response");

    // Response payload isn't what we're expecting
    if (data == none)
    {
        BroadcastMessageToAll("");
        BroadcastMessageToAll("Remote service returned an unexpected payload.", sRankedModeChatColour);
        BroadcastMessageToAll("Trying again in" @ fRankedModeMatchMakeInterval @ "seconds...", sRankedModeChatColour);
        BroadcastMessageToAll("");
        return;
    }

    // Remote service was unable to make a match
    if (data.GetBoolValue("success") == false)
    {
        BroadcastMessageToAll("");
        BroadcastMessageToAll("Remote service was unable to make a match.", sRankedModeChatColour);
        if (data.GetStringValue("error") != "")
            BroadcastMessageToAll("error: '" @ data.GetStringValue("error") @ "'", sRankedModeChatColour);
        BroadcastMessageToAll("Trying again in" @ fRankedModeMatchMakeInterval @ "seconds...", sRankedModeChatColour);
        BroadcastMessageToAll("");
        return;
    }

    // Complete success :)
    BroadcastMessageToAll("Match successfully made!", sRankedModeChatColour);

    // Ensure we stop polling for a match
    bRankedModeMatchMade = true;
    ClearTimer('RankedModeAttemptToMakeMatch');

    // Save response payload
    sRankedModeMatchResponseData = Response.GetContentAsString();

    // Extract teams from response
    class'RankedAPI'.static.GetTeamPlayerIDs(sRankedModeMatchResponseData, AgathaPlayerIDs, MasonPlayerIDs);

    // Lock and force teams
    LockTeams(AgathaPlayerIDs, MasonPlayerIDs);

    // Broadcast the match info to everyone in the server
    BroadcastMessageToAll("");
    RankedModeBroadcastMatchInfo();
    BroadcastMessageToAll("");

    // Change team names to average elo of each team
    team = data.GetObject("items").GetObject("Team1");
    AOCGRI(GameReplicationInfo).AgathaNameOverride = "[" $ team.GetIntValue("eloSum") / team.GetObject("players").ObjectArray.Length $ "]";
    team = data.GetObject("items").GetObject("Team2");
    AOCGRI(GameReplicationInfo).MasonNameOverride =  "[" $ team.GetIntValue("eloSum") / team.GetObject("players").ObjectArray.Length $ "]";

    // Start the match
    bRankedModeReadyToStartMatch = true;
}

function RankedModeEndGame()
{
    local JsonObject jMatchResponseData,
                     jResponse,
                     jItems,
                     jTeamOne,
                     jTeamTwo,
                     jTeamOnePlayers,
                     jTeamTwoPlayers,

                     jTeamOneKPI,
                     jTeamTwoKPI,
                     jPlayer,
                     jPlayerKPI,
                     jCompletedMatchRequestData;
    local EAOCFaction WinningTeam;
    local AOCGRI GRI;
    local float teamOneScore,
                teamOneProgress,
                teamTwoScore,
                teamTwoProgress;
    local `{GAMEMODE}PRI PRI;
    local int winner,
              i;


    jMatchResponseData = class'JsonObject'.static.DecodeJson(sRankedModeMatchResponseData);
    jCompletedMatchRequestData = class'JsonObject'.static.DecodeJson(sRankedModeMatchResponseData);

    // Get each nested object
    jResponse = jMatchResponseData.GetObject("response");
    jItems = jResponse.GetObject("items");
    jTeamOne = jItems.GetObject("Team1");
    jTeamTwo = jItems.GetObject("Team2");
    jTeamOnePlayers = jTeamOne.GetObject("players");
    jTeamTwoPlayers = jTeamTwo.GetObject("players");


    // Get winning team
    WinningTeam = GetWinningTeam();
    if (WinningTeam == EFAC_AGATHA)
        winner = 1;
    else if (WinningTeam == EFAC_MASON)
        winner = 2;
    else
        winner = 0;


    // Get each team's KPIs
    GRI = AOCGRI(GameReplicationInfo);
    teamOneScore = GRI.GetTeamScore(EFAC_AGATHA);
    teamOneProgress = GRI.GetTeamProgress(EFAC_AGATHA);

    teamTwoScore = GRI.GetTeamScore(EFAC_MASON);
    teamTwoProgress = GRI.GetTeamProgress(EFAC_MASON);

    // Create team KPI objects
    jTeamOneKPI = new class'JsonObject';
    jTeamOneKPI.SetFloatValue("score", teamOneScore);
    jTeamOneKPI.SetFloatValue("progress", teamOneProgress);
    
    jTeamTwoKPI = new class'JsonObject';
    jTeamTwoKPI.SetFloatValue("score", teamTwoScore);
    jTeamTwoKPI.SetFloatValue("progress", teamTwoProgress);


    // Extend the player objects with their respective KPIs
    for (i = 0; i < jTeamOnePlayers.ObjectArray.Length; i++)
    {
        jPlayer = jTeamOnePlayers.ObjectArray[i];

        PRI = `{GAMEMODE}PRI(GetPlayerReplicationInfoViaSteamID64(jPlayer.GetStringValue("_id")));
        if (PRI == none)
            continue;

        // Create KPI object
        jPlayerKPI = new class'JsonObject';
        jPlayerKPI.SetIntValue("score",   PRI.Score);
        jPlayerKPI.SetIntValue("kills",   PRI.NumKills);
        jPlayerKPI.SetIntValue("deaths",  PRI.Deaths);
        jPlayerKPI.SetIntValue("assists", PRI.NumAssists);

        jPlayerKPI.SetIntValue("healthRegenerated",             PRI.HealthRegenerated);
        jPlayerKPI.SetIntValue("healthDamageReceivedFromAll",   PRI.AllDamageTaken);
        jPlayerKPI.SetIntValue("healthDamageReceivedFromEnemy", PRI.DamageTaken);
        jPlayerKPI.SetIntValue("healthDamageReceivedFromTeam",  PRI.TeamDamageTaken);
        jPlayerKPI.SetIntValue("healthDamageDealtToEnemy",      PRI.EnemyDamageDealt);
        jPlayerKPI.SetIntValue("healthDamageDealtToTeam",       PRI.TeamDamageDealt);

        jPlayerKPI.SetFloatValue("staminaRegenerated",           PRI.StaminaRegenerated);
        jPlayerKPI.SetFloatValue("staminaDamageReceivedFromAll", PRI.AllStaminaConsumed);
        jPlayerKPI.SetIntValue("staminaDamageReceivedFromEnemy", PRI.EnemyStaminaDamageTaken);
        jPlayerKPI.SetIntValue("staminaDamageReceivedFromTeam",  PRI.TeamStaminaDamageTaken);
        jPlayerKPI.SetIntValue("staminaDamageDealtToEnemy",      PRI.EnemyStaminaDamageDealt);
        jPlayerKPI.SetIntValue("staminaDamageDealtToTeam",       PRI.TeamStaminaDamageDealt);

        jPlayerKPI.SetIntValue("feints", PRI.Feints);

        jPlayerKPI.SetIntValue("attacks",           PRI.NumAttacks);
        jPlayerKPI.SetIntValue("successfulAttacks", PRI.NumHits);

        jPlayerKPI.SetIntValue("meleeHits",      PRI.MeleeHits);
        jPlayerKPI.SetIntValue("projectileHits", PRI.ProjectileHits);
        jPlayerKPI.SetIntValue("lightShoveHits", PRI.LightShoveHits);
        jPlayerKPI.SetIntValue("heavyShoveHits", PRI.HeavyShoveHits);

        jPlayerKPI.SetIntValue("parries", PRI.Parries);
        jPlayerKPI.SetIntValue("blocks",  PRI.Blocks);

        jPlayerKPI.SetIntValue("crouches", PRI.Crouches);
        jPlayerKPI.SetIntValue("jumps",    PRI.Jumps);
        jPlayerKPI.SetIntValue("dodges",   PRI.Dodges);

        jPlayerKPI.SetIntValue("objectivePoints", PRI.ObjPoints);

        jPlayerKPI.SetIntValue("decapitations", PRI.NumDecaps);
        jPlayerKPI.SetIntValue("chatter",       PRI.Chatter);

        // Extend original object
        jTeamOnePlayers.ObjectArray[i].SetObject("kpi", jPlayerKPI);
    }

    for (i = 0; i < jTeamTwoPlayers.ObjectArray.Length; i++)
    {
        jPlayer = jTeamTwoPlayers.ObjectArray[i];

        PRI = `{GAMEMODE}PRI(GetPlayerReplicationInfoViaSteamID64(jPlayer.GetStringValue("_id")));
        if (PRI == none)
            continue;

        jPlayerKPI = new class'JsonObject';
        jPlayerKPI.SetIntValue("score",   PRI.Score);
        jPlayerKPI.SetIntValue("kills",   PRI.NumKills);
        jPlayerKPI.SetIntValue("deaths",  PRI.Deaths);
        jPlayerKPI.SetIntValue("assists", PRI.NumAssists);

        jPlayerKPI.SetIntValue("healthRegenerated",             PRI.HealthRegenerated);
        jPlayerKPI.SetIntValue("healthDamageReceivedFromAll",   PRI.AllDamageTaken);
        jPlayerKPI.SetIntValue("healthDamageReceivedFromEnemy", PRI.DamageTaken);
        jPlayerKPI.SetIntValue("healthDamageReceivedFromTeam",  PRI.TeamDamageTaken);
        jPlayerKPI.SetIntValue("healthDamageDealtToEnemy",      PRI.EnemyDamageDealt);
        jPlayerKPI.SetIntValue("healthDamageDealtToTeam",       PRI.TeamDamageDealt);

        jPlayerKPI.SetFloatValue("staminaRegenerated",           PRI.StaminaRegenerated);
        jPlayerKPI.SetFloatValue("staminaDamageReceivedFromAll", PRI.AllStaminaConsumed);
        jPlayerKPI.SetIntValue("staminaDamageReceivedFromEnemy", PRI.EnemyStaminaDamageTaken);
        jPlayerKPI.SetIntValue("staminaDamageReceivedFromTeam",  PRI.TeamStaminaDamageTaken);
        jPlayerKPI.SetIntValue("staminaDamageDealtToEnemy",      PRI.EnemyStaminaDamageDealt);
        jPlayerKPI.SetIntValue("staminaDamageDealtToTeam",       PRI.TeamStaminaDamageDealt);

        jPlayerKPI.SetIntValue("feints", PRI.Feints);

        jPlayerKPI.SetIntValue("attacks",           PRI.NumAttacks);
        jPlayerKPI.SetIntValue("successfulAttacks", PRI.NumHits);

        jPlayerKPI.SetIntValue("meleeHits",      PRI.MeleeHits);
        jPlayerKPI.SetIntValue("projectileHits", PRI.ProjectileHits);
        jPlayerKPI.SetIntValue("lightShoveHits", PRI.LightShoveHits);
        jPlayerKPI.SetIntValue("heavyShoveHits", PRI.HeavyShoveHits);

        jPlayerKPI.SetIntValue("parries", PRI.Parries);
        jPlayerKPI.SetIntValue("blocks",  PRI.Blocks);

        jPlayerKPI.SetIntValue("crouches", PRI.Crouches);
        jPlayerKPI.SetIntValue("jumps",    PRI.Jumps);
        jPlayerKPI.SetIntValue("dodges",   PRI.Dodges);

        jPlayerKPI.SetIntValue("objectivePoints", PRI.ObjPoints);

        jPlayerKPI.SetIntValue("decapitations", PRI.NumDecaps);
        jPlayerKPI.SetIntValue("chatter",       PRI.Chatter);

        jTeamTwoPlayers.ObjectArray[i].SetObject("kpi", jPlayerKPI);
    }


    // Build request payload
    jTeamOne.SetObject("players", jTeamOnePlayers);
    jTeamOne.SetObject("kpi", jTeamOneKPI);

    jTeamTwo.SetObject("players", jTeamTwoPlayers);
    jTeamTwo.SetObject("kpi", jTeamTwoKPI);

    jItems.SetObject("Team1", jTeamOne);
    jItems.SetObject("Team2", jTeamTwo);

    jResponse.SetObject("items", jItems);
    jResponse.SetIntValue("winner", winner);

    jCompletedMatchRequestData.SetObject("response", jResponse);


    class'RankedAPI'.static.CalculateNewElos(class'JsonObject'.static.EncodeJson(jCompletedMatchRequestData), CalculateNewElosOnComplete);
}

function CalculateNewElosOnComplete(HttpRequestInterface OriginalRequest, HttpResponseInterface Response, bool bDidSucceed)
{
    if (bDidSucceed)
        BroadcastMessageToAll("Match result successfully sent to the remote service.", sRankedModeChatColour);
    else
        BroadcastMessageToAll("Failed to send match result to the remote service.", sRankedModeChatColour);
}

// Custom player votes
function InitiateCustomVote(AOCPlayerController VoteInstigator, delegate<CustomVoteOnComplete> OnComplete, optional float duration, optional string PrimaryText, optional string SecondaryText)
{
    local AOCPlayerController PC;
    local int FailReasonPMCode;

    if (!IsAllowedToInitiateVote(VoteInstigator, FailReasonPMCode))
    {
        LocalizedPrivateMessage(VoteInstigator, FailReasonPMCode);
        return;
    }

    if (!bEnableVoteResetMap)
    {
        LocalizedPrivateMessage(VoteInstigator, iLocMapResetVotesDisabled);
        return;
    }

    // Set delegate to execute when complete
    dCustomVoteOnComplete = OnComplete;

    // Overrride vote duration 
    if (duration >= 10 && duration <= 60)
        fVoteDurationSeconds = duration;

    VoteCategory = EVOTECAT_RestartMap;

    fTimeVoteStarted = Worldinfo.TimeSeconds;
    SetTimer(fVoteDurationSeconds, false, 'EndCustomVote');

    foreach WorldInfo.AllControllers(class'AOCPlayerController', PC)
    {
        PC.BeginVote(EVOTECAT_RestartMap, "", fVoteDurationSeconds);
        `{GAMEMODE}PlayerController(PC).OverrideVoteText(PrimaryText, SecondaryText);
    }

    AOCGRI(GameReplicationInfo).VotesNo = 0;
    AOCGRI(GameReplicationInfo).VotesYes = 0;

    InitiateNewVote(VoteInstigator);
    VoteInstigator.Vote = EVOTE_Yes;

    SetTimer(0.5f, true, 'CountVotes');
}

function EndCustomVote()
{
    local bool bSuccess;
    local AOCPlayerController PC;

    ClearTimer('CountVotes');
    bSuccess = DidVoteSucceed();

    EndVoting();

    foreach WorldInfo.AllControllers(class'AOCPlayerController', PC)
    {
        PC.FinishVote(bSuccess, fVoteEnactDelaySeconds);
    }

    // Execute delegate with the result of the vote if it exists
    if (dCustomVoteOnComplete != none)
    {
        dCustomVoteOnComplete(bSuccess);
        dCustomVoteOnComplete = none;
    }
}

function InitiateVoteTournamentMode(AOCPlayerController VoteInstigator, bool bEnable)
{
    if (default.bTournamentMode == bEnable)
    {
        VoteInstigator.ReceiveChatMessage("TournamentMode is already" @ bEnable ? "enabled." : "disabled.", EFAC_ALL, true);
        return;
    }

    InitiateCustomVote(VoteInstigator, VoteTournamentModeOnComplete, , bEnable ? "Enable?" : "Disable?", "TournamentMode");
}

function VoteTournamentModeOnComplete(bool bSuccess)
{
    if (!bSuccess)
        return;

    // If we're enabling, ensure RankedMode is disabled
    if (!default.bTournamentMode)
        ConfigureRankedMode(false);

    ConfigureTournamentMode(!default.bTournamentMode);
    WorldInfo.ServerTravel("?restart", false);
}

function InitiateVoteRankedMode(AOCPlayerController VoteInstigator, bool bEnable)
{
    if (bRankedMode == bEnable)
    {
        VoteInstigator.ReceiveChatMessage("RankedMode is already" @ bEnable ? "enabled." : "disabled.", EFAC_ALL, true);
        return;
    }

    InitiateCustomVote(VoteInstigator, VoteRankedModeOnComplete, , bEnable ? "Enable?" : "Disable?", "RankedMode");
}

function VoteRankedModeOnComplete(bool bSuccess)
{
    if (!bSuccess)
        return;

    // If we're enabling, ensure TournamentMode is disabled
    if (!bRankedMode)
        ConfigureTournamentMode(false);

    ConfigureRankedMode(!bRankedMode);
    WorldInfo.ServerTravel("?restart", false);
}

function InitiateVoteRankedTeamSize(AOCPlayerController VoteInstigator, int Size)
{
    if (Size <= 0 || Size > (MaxPlayers / 2))
    {
        VoteInstigator.ReceiveChatMessage("RankedTeamSize cannot be set to" @ Size $ ".", EFAC_ALL, true);
        return;
    }
    if (iRankedTeamSize == Size)
    {
        VoteInstigator.ReceiveChatMessage("RankedTeamSize is already" @ Size $ ".", EFAC_ALL, true);
        return;
    }

    iVoteRankedTeamSize = Size;
    InitiateCustomVote(VoteInstigator, VoteRankedTeamSizeOnComplete, 15.0, string(Size), "RankedTeamSize");
}

function VoteRankedTeamSizeOnComplete(bool bSuccess)
{
    if (!bSuccess)
        return;

    BroadcastMessageToAll("RankedTeamSize" @ iVoteRankedTeamSize);

    ConfigureRankedTeamSize(iVoteRankedTeamSize);
    iVoteRankedTeamSize = 0;
}

function InitiateVoteRestartMapAfterEndGame(AOCPlayerController VoteInstigator, bool bEnable)
{
    if (bRestartMapAfterEndGame == bEnable)
    {
        VoteInstigator.ReceiveChatMessage("RestartMapAfterEndGame is already" @ bEnable ? "enabled." : "disabled.", EFAC_ALL, true);
        return;
    }

    InitiateCustomVote(VoteInstigator, VoteRestartMapAfterEndGameOnComplete, , bEnable ? "Enable?" : "Disable?", "RestartMapAfterEndGame");
}

function VoteRestartMapAfterEndGameOnComplete(bool bSuccess)
{
    if (!bSuccess)
        return;

    BroadcastMessageToAll("RestartMapAfterEndGame" @ !bRestartMapAfterEndGame);
    ConfigureRestartMapAfterEndGame(!bRestartMapAfterEndGame);
}


DefaultProperties
{
    ModDisplayString="ImbaMod"


    AccessControlClass=class'ImbaModAccessControl'
    PlayerControllerClass=class'`{GAMEMODE}PlayerController'
    PlayerReplicationInfoClass=class'`{GAMEMODE}PRI'
    DefaultPawnClass=class'`{GAMEMODE}Pawn'
    HUDType=class'`{GAMEMODE}HUD'

    Families.Empty;
    Families(ECLASS_Archer)=class'ImbaModFamilyInfo_Agatha_Archer'
    Families(ECLASS_ManAtArms)=class'ImbaModFamilyInfo_Agatha_ManAtArms'
    Families(ECLASS_Vanguard)=class'ImbaModFamilyInfo_Agatha_Vanguard'
    Families(ECLASS_Knight)=class'ImbaModFamilyInfo_Agatha_Knight'
    Families(ECLASS_SiegeEngineer)=class'ImbaModFamilyInfo_Agatha_Archer'
    Families(5)=class'ImbaModFamilyInfo_Mason_Archer'
    Families(6)=class'ImbaModFamilyInfo_Mason_ManAtArms'
    Families(7)=class'ImbaModFamilyInfo_Mason_Vanguard'
    Families(8)=class'ImbaModFamilyInfo_Mason_Knight'
    Families(9)=class'ImbaModFamilyInfo_Mason_Archer'


    MinimumRespawnTime = 10.0f
    bDisableTeamDamagePenalty = true

    fRankedModeMatchMakeInterval = 30.0
    sRankedModeChatColour = "#00BFFF"
}
